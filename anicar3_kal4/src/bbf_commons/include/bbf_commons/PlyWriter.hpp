/*
 * Copyright 2014. All rights reserved.
 * Institute of Measurement and Control Systems
 * Karlsruhe Institute of Technology, Germany
 *
 * authors:
 *  Johannes Graeter (johannes.graeter@kit.edu)
 *  and others
 */
#ifndef PLYWRITER_HPP
#define PLYWRITER_HPP
#include <string>
#include <vector>
#include <cassert>
#include <fstream>
#include <sstream>
#include <math.h>

#include <Eigen/Core>

/*@class PlyWriter
* @par
*
* write wrapper to write down pointclouds and geometries into plys
*/
class PlyWriter
{
public: /* public classes/enums/types etc... */

public: /* public methods */

    /*
  * default constructor
  */
    PlyWriter(){;}

    PlyWriter(std::string NameOfFile, bool Centered=false):
        NameOfFile(NameOfFile)
      ,Centered(Centered)
    {
        reset();
    }

    /*
  * default destructor
  */
    virtual ~PlyWriter(){;}

    /**
     * @brief write
     */
    void write()
    {
        if (Centered)
        {
            //calc mean
            Eigen::Vector3d Mean=Eigen::Vector3d::Zero();
            for ( auto & P:AllPoints)
            {
                Mean=Mean+P.first;
            }
            Mean=Mean*(1./float(AllPoints.size()));

            //center around mean
            for ( auto & P:AllPoints)
            {
                P.first=P.first-Mean;
            }
        }

        for ( auto & P:AllPoints)
        {
            add_point_to_body(P.first,P.second);
        }

        file_.open(NameOfFile);
        if (NumberVertices>0)
        {
            Header << "element vertex " <<  NumberVertices << "\n";
            Header << "property float x\n";
            Header << "property float y\n";
            Header << "property float z\n";
            Header << "property uchar red\n";
            Header << "property uchar green\n";
            Header << "property uchar blue\n";
        }
        if (NumberFaces>0)
        {
            Header << "element face "<<NumberFaces<<"\n";
            Header << "property list uchar int vertex_index\n";
        }
        Header << "end_header\n";

        file_<<Header.rdbuf();
        file_<<Body.rdbuf();
        file_<<Footer.rdbuf();

        file_.close();

        reset();
    }
    /**
     * @brief reset
     */
    void reset()
    {
        NumberVertices=4; //4 because of 0,0,0 and axes
        NumberFaces=0;
        NumberEdges=0;

        //first entries to header
        Header.str("");
        Body.str("");
        Footer.str("");

        Header << "ply\n";
        Header << "format ascii 1.0\n";
        Header << "comment generated by PlyWriter\n";

        //add origin
        Body
                << 0.0 <<" "
                << 0.0 <<" "
                << 0.0 <<" "
                << 150 << " "
                << 150 << " "
                << 150 << "\n";
        Body
                << 1.0 <<" "
                << 0.0 <<" "
                << 0.0 <<" "
                << 150 << " "
                << 0 << " "
                << 0 << "\n";
        Body
                << 0.0 <<" "
                << 1.0 <<" "
                << 0.0 <<" "
                << 0 << " "
                << 150 << " "
                << 0 << "\n";
        Body
                << 0.0 <<" "
                << 0.0 <<" "
                << 1.0 <<" "
                << 0 << " "
                << 0 << " "
                << 150 << "\n";
    }

    /**
     * @brief clear points and reset
     * @return  void
     * @par ...
     */
    void clear()
    {
        AllPoints.clear();
        reset();
    }

    /**
     * @brief add_point_to_body
     * @param P
     * @param RGB
     */
    template<typename T>
    void add_point_to_body(const Eigen::Matrix<T,3,1>& P,std::tuple<uint,uint,uint> RGB)
    {
        assert (std::get<0>(RGB)<256 && std::get<1>(RGB)<256 &&std::get<2>(RGB)<256 && "RGB must be in range [0,255]");
        NumberVertices=NumberVertices+1;
        Body
                << P(0) <<" "
                << P(1) <<" "
                << P(2) <<" "
                << std::get<0>(RGB) << " "
                << std::get<1>(RGB) << " "
                << std::get<2>(RGB) << "\n";
    }

    /**
     * @brief add_point
     * @param P
     * @param RGB
     */
    template<typename T>
    void add_point(const Eigen::Matrix<T,3,1>& P, std::tuple<uint,uint,uint> RGB)
    {
        bool c=std::is_convertible<T,double>::value;
        assert(c);
        AllPoints.push_back(std::make_pair(P.template cast<double>(),RGB));
    }

    /**
     * @brief add_point
     * @param P
     * @param RGB
     */
    template<typename T>
    void add_point(const Eigen::Matrix<T,3,1>& P, std::tuple<int,int,int> RGB)
    {
        assert(std::get<0>(RGB)>-1 && std::get<1>(RGB)>-1 &&std::get<2>(RGB)>-1 && "RGB can not be negative");
        bool c=std::is_convertible<T,double>::value;
        assert(c);
        std::tuple<uint,uint,uint> UIntRGB=std::make_tuple(uint(std::get<0>(RGB)),uint( std::get<1>(RGB)),uint(std::get<2>(RGB)));
        AllPoints.push_back(std::make_pair(P.template cast<double>(),UIntRGB));
    }

    /**
     * @brief add_points to vector
     * @param PCL
     * @param RGB
     */
    template<typename T>
    void add_points(const std::vector<Eigen::Matrix<T,3,1>>& PCL,std::tuple<uint,uint,uint> RGB)
    {
        for ( auto & P:PCL)
        {
            add_point(P,RGB);
        }
    }

    /**
     * @brief add_points to vector
     * @param PCL
     * @param RGB
     * @todo evtl template
     */
    template<typename T>
    void add_points(const std::vector<Eigen::Matrix<T,3,1>>& PCL,std::tuple<int,int,int> RGB)
    {

        for ( auto & P:PCL)
        {
            add_point(P,RGB);
        }
    }
    /**
     * @brief add_face
     * @param SupportPoints
     */
    template<typename T>
    void add_face(const std::vector<Eigen::Matrix<T,3,1>>& SupportPoints)
    {
        NumberFaces++;
        //assign mesh for face
        Footer << SupportPoints.size() ;
        for (size_t i = 0; i < SupportPoints.size(); ++i)
        {
            Footer<<" "<<NumberVertices+i;
        }
        Footer<<"\n";

        for ( auto & el:SupportPoints)
        {
            add_point_to_body(el,std::make_tuple(254,254,254));
        }
    }

    /**
     * @brief add a square in the given plane with Area Edgelength^2 around PointNearMiddle(does not have to be part of the plane)
     * @return  void
     * @par ...
     */
    template<typename T>
    void add_square_of_plane(Eigen::Matrix<T,3,1> Normal,T d,Eigen::Matrix<T,3,1> PointNearMiddle,T EdgeLength)
    {
        bool c=std::is_convertible<T,double>::value;
        assert(c);
        Normal=Normal.template cast<double>();
        PointNearMiddle=PointNearMiddle.template cast<double>();
        //to be sure normal has unit length
        Normal=Normal/Normal.norm();

        Eigen::Vector3d ProjectedPoint=PointNearMiddle-(Normal.transpose()*PointNearMiddle-d)*Normal;
        assert(std::abs(Normal.transpose()*ProjectedPoint-d)<0.01&&"error in point projection");
        //sample for points in plane around PointNearMiddle
        Eigen::Vector3d Cur(1.,1.,1.);
        Eigen::Vector3d PointNearMiddle2=PointNearMiddle+Cur;
        Eigen::Vector3d ProjectedPoint2=PointNearMiddle2-(Normal.transpose()*PointNearMiddle2-d)*Normal;
        assert(std::abs(Normal.transpose()*ProjectedPoint2-d)<0.01&&"error in pint projection");
        Eigen::Vector3d V1= ProjectedPoint-ProjectedPoint2;
        V1=V1/V1.norm();
        auto V2=V1.cross(Normal);

        std::vector<Eigen::Vector3d> SamplePoints(4);
        SamplePoints[0]=V1*EdgeLength/2.+ProjectedPoint;
        SamplePoints[1]=V2*EdgeLength/2.+ProjectedPoint;
        SamplePoints[2]=-V1*EdgeLength/2.+ProjectedPoint;
        SamplePoints[3]=-V2*EdgeLength/2.+ProjectedPoint;

        add_face(SamplePoints);
    }

public: /*attributes*/
    ///@brief Name of file whcih is written down
    std::string NameOfFile;

    ///@brief Centered, if true all points will be centered around their mean
    bool Centered;

    ///@brief AllPoints, store all points in vector if is to be centered
    std::vector<std::pair<Eigen::Matrix<double,3,1>,std::tuple<uint,uint,uint>>> AllPoints;

    std::ofstream file_;
    std::stringstream Header;
    std::stringstream Body;
    std::stringstream Footer;
    uint32_t NumberVertices;
    uint32_t NumberEdges; //not yet implemented
    uint32_t NumberFaces;
};


#endif // PLYWRITER_HPP
